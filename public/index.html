<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>SpectreBolt Arena</title>
    <link rel="icon" type="image/png" href="/download.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SpectreBolt">
    <link rel="apple-touch-icon" href="/download.png">
    <style>
        :root {
            --ui-bg: rgba(0, 0, 0, 0.7);
            --accent: #0f4;
            --sprint: #0cf;
        }

        
        @media screen and (orientation: portrait) {
            #portrait-warning {
                display: flex !important;
            }
        }

        #portrait-warning {
            display: none; position: fixed; inset: 0; background: #222; z-index: 9999;
            color: white; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 20px;
        }

        body { 
            margin: 0; overflow: hidden; background: #111; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            touch-action: none; user-select: none; -webkit-user-select: none;
            width: 100vw; height: 100dvh; position: fixed;
        }

        @media screen and (orientation: portrait) {
            #portrait-warning {
                display: flex !important;
            }
        }


        canvas { display: block; }
        #killFeed {
            position: fixed;
            top: 80px;
            right: 15px;
            text-align: right;
            pointer-events: none;
            z-index: 100;
        }
        .kill-msg {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 14px;
            animation: fadeOut 4s forwards;
        }
        @keyframes fadeOut {
            0% { opacity: 1; transform: translateX(0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateX(20px); }
        }
        
        #nameScreen, #gameOver {
            position: fixed; inset: 0; background: #222; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        #nameScreen h1 { color: white; font-size: 56px; margin-bottom: 30px; letter-spacing: 5px; }
        #nameScreen input { 
            padding: 15px; font-size: 20px; border-radius: 5px; border: none; 
            width: 280px; text-align: center; outline: none;
        }
        #nameScreen button, #gameOver button { 
            margin-top: 25px; padding: 15px 50px; font-size: 22px; 
            background: var(--accent); border: none; cursor: pointer; 
            font-weight: bold; border-radius: 5px; transition: transform 0.1s;
        }

        
        #ui, #leaderboard {
            position: fixed; top: 15px; color: white;
            background: var(--ui-bg); padding: 15px; border-radius: 10px; 
            pointer-events: none; z-index: 10; font-size: 14px;
        }
        #ui { left: 15px; min-width: 160px; }
        #leaderboard { right: 15px; text-align: right; min-width: 140px; }

        .bar-bg { width: 100%; height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin-top: 5px; }
        #staminaBar { width: 100%; height: 100%; background: var(--sprint); transition: width 0.1s; }
        #timer { font-size: 22px; font-weight: bold; color: var(--accent); margin-bottom: 8px; }
        #score {
            font-size: 20px;
            color: var(--sprint);
            margin-top: 15px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
        }

        
        #mobileControls {
            display: none; position: fixed; inset: 0; z-index: 500; pointer-events: none;
        }
        @media (pointer: coarse) { #mobileControls { display: block; } }

        .joystick-base {
            position: absolute; bottom: 40px; left: 60px; width: 140px; height: 140px;
            background: rgba(255,255,255,0.1); border-radius: 50%; pointer-events: auto;
        }
        .joystick-knob {
            position: absolute; top: 45px; left: 45px; width: 50px; height: 50px;
            background: rgba(255,255,255,0.4); border-radius: 50%;
        }

        .action-btn {
            position: absolute; border-radius: 50%; display: flex; align-items: center; 
            justify-content: center; color: white; font-weight: bold; pointer-events: auto;
        }
        #sprintBtn {
            bottom: 40px; right: 40px; width: 80px; height: 80px;
            background: rgba(0, 150, 255, 0.6); border: 3px solid rgba(255,255,255,0.2);
            font-size: 14px;
        }

        
        #minimap-container {
            position: fixed; bottom: 20px; left: 20px; width: 140px; height: 140px;
            background: rgba(0, 0, 0, 0.6); border: 2px solid #555; border-radius: 8px;
            overflow: hidden; z-index: 5;
        }
        #minimap-canvas { display: block; }
        #mapToggle {
            display: none; position: fixed; bottom: 170px; left: 20px; padding: 8px 12px;
            background: var(--ui-bg); color: white; border: 1px solid #555;
            border-radius: 5px; font-size: 10px; pointer-events: auto; z-index: 10;
        }
        @media (pointer: coarse) { #mapToggle { display: block; } }

        #ios-prompt {
            display: none; position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%); width: 90%; max-width: 350px;
            background: white; color: black; padding: 15px; border-radius: 12px;
            z-index: 9999; box-shadow: 0 10px 25px rgba(0,0,0,0.5); font-size: 14px;
        }
        #ios-prompt .close-prompt {
            position: absolute; top: 5px; right: 10px; font-size: 20px; cursor: pointer;
        }
        #ios-prompt b { color: #007aff; } 
    </style>
</head>
<body>

    <div id="portrait-warning">
        <h2>PLEASE ROTATE TO LANDSCAPE</h2>
        <p>This game is best played in landscape mode.</p>
        <p>Tap to shoot when you enter</p>
    </div>
    
    <div id="ios-prompt">
        <span class="close-prompt" onclick="document.getElementById('ios-prompt').style.display='none'">&times;</span>
        <p style="margin: 0;">
            <b>Play Fullscreen:</b> Tap the <img src="ios-share.png" width="15" style="vertical-align: middle;"> button and select <b>"Add to Home Screen"</b>.
        </p>
    </div>

    <div id="nameScreen">
        <h1>SpectreBolt Arena</h1>
        <input type="text" id="nameInput" placeholder="NICKNAME" maxlength="12">
        <button id="startBtn">JOIN ARENA</button>
    </div>
    <div id="killFeed"></div>
    <div id="gameOver" style="display:none;">
        <h1 style="color: var(--accent);">ARENA CLOSED</h1>
        <div id="winnerList" style="font-size: 24px; text-align: center; color: white;"></div>
        <div id="score"></div>
        <button onclick="location.reload()">REMATCH</button>
    </div>

    <button id="mapToggle">HIDE MAP</button>
    <div id="minimap-container">
        <canvas id="minimap-canvas" width="140" height="140"></canvas>
    </div>

    <div id="ui">
        <div id="timer">TIME: 15:00</div>
        <div>HP: <span id="hpText">100</span> | Lives: <span id="livesText">3</span></div>
        <div class="bar-bg"><div id="staminaBar"></div></div>
    </div>

    <div id="leaderboard">
        <div style="border-bottom: 1px solid #555; margin-bottom: 5px; padding-bottom: 2px;"><b>LEADERBOARD</b></div>
        <div id="scoreList"></div>
    </div>

    <div id="mobileControls">
        <div id="moveJoystick" class="joystick-base">
            <div id="moveKnob" class="joystick-knob"></div>
        </div>
        <div id="sprintBtn" class="action-btn">RUN</div>
    </div>

    <canvas id="game"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io({ transports: ['websocket'], upgrade: false });
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const lerp = (a, b, t) => a + (b - a) * t;

        let myId, mapSize, walls = [];
        let players = {}, bots = {}, bullets = {}, matchTimer = 1200;
        let keys = {};
        let mouseAngle = 0;
        let isMobileSprinting = false;
        let joy = { active: false, x: 0, y: 0, identifier: null };
        let camX=0; let camY=0;
        let moveTouchId = null;

        
        window.addEventListener('load', () => {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isStandalone = window.navigator.standalone === true || window.matchMedia('(display-mode: standalone)').matches;
            if (isIOS && !isStandalone) {
                document.getElementById('ios-prompt').style.display = 'block';
            }
        });

        async function requestFullScreen() {
            const el = document.documentElement;
            try {
                if (el.requestFullscreen) await el.requestFullscreen();
                else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
                if (screen.orientation && screen.orientation.lock) {
                    await screen.orientation.lock('landscape').catch(()=>{});
                }
            } catch (err) { console.log(err); }
        }

        function resizeCanvas(){
            canvas.width = window.innerWidth;
            canvas.height=window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        document.getElementById('startBtn').onclick = () => {
            requestFullScreen();
            const name = document.getElementById('nameInput').value;
            socket.emit('joinGame', { name: name || "Sniper" });
            document.getElementById('nameScreen').style.display = 'none';
        };

        
        const joyBase = document.getElementById('moveJoystick');
        const joyKnob = document.getElementById('moveKnob');

        const updateJoystick = (touch) => {
            const rect = joyBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;

            const maxDist = 45;
            const dist = Math.min(maxDist, Math.hypot(dx, dy));
            const angle = Math.atan2(dy, dx);

            joy.x = (Math.cos(angle) * dist) / maxDist;
            joy.y = (Math.sin(angle) * dist) / maxDist;

            if (Math.hypot(joy.x, joy.y) < 0.15) {
                joy.x = 0;
                joy.y = 0;
            }

            joyKnob.style.transform =
                `translate(${joy.x * maxDist}px, ${joy.y * maxDist}px)`;
        };

        function handleTapToShoot(touch) {
            if (!players[myId] || players[myId].isSpectating) return;
            const angle = Math.atan2(touch.clientY - window.innerHeight / 2, touch.clientX - window.innerWidth / 2);
            mouseAngle = angle;
            socket.emit('fire', { angle: angle });
        }

        canvas.addEventListener('touchstart', e => {
            for (const t of e.changedTouches) {
                if (moveTouchId === null && t.clientX < window.innerWidth / 2) {
                    moveTouchId = t.identifier;
                    joy.active = true;
                    joy.identifier = t.identifier;
                    updateJoystick(t);
                } else if (t.target.id !== 'sprintBtn' && t.target.id !== 'mapToggle') {
                    handleTapToShoot(t);
                }
            }
        }, { passive: false });



        canvas.addEventListener('touchmove', e => {
            for (const t of e.changedTouches) {
                if (t.identifier === moveTouchId) {
                    updateJoystick(t);
                }
            }
        }, { passive: false });


        canvas.addEventListener('touchend', e => {
            for (const t of e.changedTouches) {
                if (t.identifier === moveTouchId) {
                    moveTouchId = null;
                    joy.active = false;
                    joy.identifier = null;
                    joy.x = 0;
                    joy.y = 0;
                    joyKnob.style.transform = `translate(0,0)`;
                }
            }
        }, { passive: false });

        document.getElementById('sprintBtn').addEventListener('touchstart', (e) => { e.preventDefault(); isMobileSprinting = true; });
        document.getElementById('sprintBtn').addEventListener('touchend', (e) => { e.preventDefault(); isMobileSprinting = false; });

        
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => {
            if (!joy.active) {
                mouseAngle = Math.atan2(e.clientY - canvas.height/2, e.clientX - canvas.width/2);
            }
        });
        window.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'CANVAS') return;
            if (players[myId] && !players[myId].isSpectating) socket.emit('fire', { angle: mouseAngle });
        });

        
        socket.on('init', d => { 
            myId = d.id; mapSize = d.mapSize; walls = d.walls; 
            players[myId] = {
                id:myId,
                x:d.spawnX || mapSize/2,
                y:d.spawnY || mapSize/2,
                angle:0,
                hp:100,
                stamina:100,
                lives:3,
                score:0,
                name:document.getElementById('nameInput').value || "Sniper",
                color:null,
                isSpectating:false,
                spawnProtected:true
            };
            if(players[myId]) { camX = players[myId].x; camY = players[myId].y; }
        });
        socket.on('killEvent', (data) => {
            const feed = document.getElementById('killFeed');
            const msg = document.createElement('div');
            msg.className='kill-msg';
            msg.innerHTML = `<span style="color:var(--accent)">${data.shooter}</span> killed ${data.victim}`;
            feed.appendChild(msg);
            setTimeout(() => msg.remove(), 4000);
        });
        socket.on('state', s => {
            matchTimer = s.matchTimer;
            bullets = s.bullets;
            bots = s.bots;

    
            Object.entries(s.players).forEach(([id, p]) => {
                if (!players[id]) players[id] = p;
                else Object.assign(players[id], p);
            });

    
            Object.keys(players).forEach(id => {
                if (!s.players[id]) delete players[id];
            });

    
            if (players[myId] && s.players[myId]) {
                players[myId].hp = s.players[myId].hp;
                players[myId].lives = s.players[myId].lives;
                players[myId].score = s.players[myId].score;
                players[myId].isSpectating = s.players[myId].isSpectating;
                players[myId].spawnProtected = s.players[myId].spawnProtected;
                players[myId].stamina = s.players[myId].stamina;
            }
        });


        socket.on('respawned', (data)=>{ camX = data.x; camY = data.y; });
        socket.on('errorMsg', (msg) => { alert(msg); document.getElementById('nameScreen').style.display = 'flex'; });
        socket.on('matchReset', ()=>{ document.getElementById('gameOver').style.display='none'; });

        
        setInterval(() => {
            const me = players[myId];
            if (!me || matchTimer <= 0) return;

            const isSprinting = keys['ShiftLeft'] || keys['ShiftRight'] || isMobileSprinting;
            let dx = 0, dy = 0;

            if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) dx += 1;

            if (joy.active) {
                dx = joy.x;
                dy = joy.y;
            }

            if (me.isSpectating) {
                me.x += dx * 15;
                me.y += dy * 15;
            }

            socket.emit('input', {
                up:    joy.active ? joy.y < 0 : keys['KeyW'] || keys['ArrowUp'],
                down:  joy.active ? joy.y > 0 : keys['KeyS'] || keys['ArrowDown'],
                left:  joy.active ? joy.x < 0 : keys['KeyA'] || keys['ArrowLeft'],
                right: joy.active ? joy.x > 0 : keys['KeyD'] || keys['ArrowRight'],
                sprint: isMobileSprinting || keys['ShiftLeft'] || keys['ShiftRight'],
                angle: mouseAngle
            });


        }, 1000/60);

        function clientCollidesWithWall(x, y, r = 20) {
            if (x < r || y < r || x > mapSize - r || y > mapSize - r) return true;
            return walls.some(w => x + r > w.x && x - r < w.x + w.w && y + r > w.y && y - r < w.y + w.h);
        }

        function drawEntity(p, color, label, isMe) {
            ctx.save();
            if (p.isSpectating) ctx.globalAlpha = 0.5;
            ctx.translate(p.x, p.y);
            if (p.spawnProtected && !p.isSpectating) {
                ctx.beginPath(); ctx.arc(0, 0, 28, 0, Math.PI * 2);
                ctx.strokeStyle = "#0cf"; ctx.lineWidth = 3; ctx.setLineDash([5, 5]); ctx.stroke();
                ctx.setLineDash([]);
            }
            if (!p.isSpectating) {
                ctx.fillStyle = "#333"; ctx.fillRect(-20, -45, 40, 6);
                ctx.fillStyle = p.hp > 30 ? "#0f4" : "#f22"; ctx.fillRect(-20, -45, (p.hp/100) * 40, 6);
            }
            ctx.save(); ctx.rotate(p.angle);
            ctx.fillStyle = color; ctx.strokeStyle = "#000"; ctx.lineWidth = 3;
            ctx.fillRect(0, -6, 32, 12); ctx.strokeRect(0, -6, 32, 12);
            ctx.restore();
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2);
            ctx.fillStyle = color; ctx.fill();
            ctx.strokeStyle = isMe ? "#fff" : "#000"; ctx.lineWidth = isMe ? 4 : 3; ctx.stroke();
            ctx.fillStyle = "white"; ctx.globalAlpha = 1; ctx.font = "bold 14px Arial"; ctx.textAlign = "center";
            ctx.fillText((p.isSpectating ? "[GHOST] " : "") + label, 0, -55);
            ctx.restore();
        }

        const miniCanvas = document.getElementById('minimap-canvas');
        const miniCtx = miniCanvas.getContext('2d');
        const mapToggle = document.getElementById('mapToggle');
        const miniContainer = document.getElementById('minimap-container');

        mapToggle.onclick = () => {
            const hidden = miniContainer.style.display === 'none';
            miniContainer.style.display = hidden ? 'block' : 'none';
            mapToggle.innerText = hidden ? 'HIDE MAP' : 'SHOW MAP';
        };

        function drawMinimap() {
            miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
            const scale = miniCanvas.width / mapSize;
            miniCtx.fillStyle = "#444";
            walls.forEach(w => miniCtx.fillRect(w.x * scale, w.y * scale, w.w * scale, w.h * scale));
            Object.values(bots).forEach(b => {
                miniCtx.fillStyle = "red"; miniCtx.beginPath();
                miniCtx.arc(b.x * scale, b.y * scale, 3, 0, Math.PI * 2); miniCtx.fill();
            });
            Object.values(players).forEach(p => {
                if (p.id !== myId) {
                    miniCtx.fillStyle = p.isSpectating ? "rgba(255,255,255,0.3)" : "white";
                    miniCtx.beginPath(); miniCtx.arc(p.x * scale, p.y * scale, 2, 0, Math.PI * 2); miniCtx.fill();
                }
            });
            const me = players[myId];
            if (me) {
                miniCtx.fillStyle = "#0f4"; miniCtx.beginPath();
                miniCtx.arc(me.x * scale, me.y * scale, 4, 0, Math.PI * 2); miniCtx.fill();
            }
        }

        function draw() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = "#111"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            const me = players[myId];
            if (!me) { requestAnimationFrame(draw); return; }
            ctx.save()

            camX += (me.x - camX) * 0.45; camY += (me.y - camY) * 0.45;
            
            ctx.translate(canvas.width/2 - camX, canvas.height/2 - camY);

            ctx.fillStyle = "#006666"; ctx.fillRect(0, 0, mapSize, mapSize);
            ctx.strokeStyle = "rgba(0,0,0,0.2)";
            for(let i=0; i<=mapSize; i+=100) {
                ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,mapSize); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(mapSize,i); ctx.stroke();
            }

            walls.forEach(w => {
                ctx.fillStyle = "#333"; ctx.fillRect(w.x, w.y, w.w, w.h);
                ctx.strokeStyle = "#000"; ctx.lineWidth = 4; ctx.strokeRect(w.x, w.y, w.w, w.h);
            });

            Object.values(bullets).forEach(b => {
                ctx.fillStyle = "yellow"; ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI*2); ctx.fill();
            });

            Object.values(bots).forEach(b => {
                b.renderX = lerp(b.renderX || b.x, b.x, 0.15); b.renderY = lerp(b.renderY || b.y, b.y, 0.15);
                drawEntity({ ...b, x: b.renderX, y: b.renderY }, b.color, b.name, false);
            });
            Object.values(players).forEach(p => {
                if (p.id === myId) return;
                p.renderX = lerp(p.renderX || p.x, p.x, 0.15); p.renderY = lerp(p.renderY || p.y, p.y, 0.15);
                drawEntity({ ...p, x: p.renderX, y: p.renderY }, p.color, p.name, false);
            });
            
            drawEntity(me, me.color, me.name, true);
            ctx.restore();

            document.getElementById('hpText').innerText = Math.ceil(me.hp);
            document.getElementById('livesText').innerText = me.lives;
            document.getElementById('staminaBar').style.width = me.stamina + "%";
            
            const mins = Math.floor(matchTimer / 60);
            const secs = Math.floor(matchTimer % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `TIME: ${mins}:${secs}`;
            
            const all = [...Object.values(players), ...Object.values(bots)].sort((a,b) => b.score - a.score).slice(0,5);
            document.getElementById('scoreList').innerHTML = all.map(p => `<div>${p.name}: ${p.score}</div>`).join('');

            if (matchTimer <= 0) {
                document.getElementById('gameOver').style.display = 'flex';
    
    
                const allEntities = [...Object.values(players), ...Object.values(bots)];
                const high = Math.max(...allEntities.map(e => e.score));
                const winners = allEntities.filter(e => e.score === high);
    
                document.getElementById('winnerList').innerHTML = `High Score: ${high}<br>` + winners.map(w => w.name).join(', ');

    
                const scoreDiv = document.getElementById('score');
                const myCurrentScore = players[myId].score;
                const savedBest = parseInt(localStorage.getItem('spectreBolt_PB')) || 0;

                if (myCurrentScore > savedBest) {
                    localStorage.setItem('spectreBolt_PB', myCurrentScore);
                    scoreDiv.innerHTML = `NEW PERSONAL BEST: ${myCurrentScore}!`;
                    scoreDiv.style.color = "var(--accent)";
                } else {
                    scoreDiv.innerHTML = `Your Score: ${myCurrentScore} | Best: ${savedBest}`;
                    scoreDiv.style.color = "white"; 
                }

                return;
            }
            drawMinimap();
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>