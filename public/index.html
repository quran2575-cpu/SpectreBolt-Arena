<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>SpectreBolt Arena</title>
    <link rel="icon" type="image/png" href="/download.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SpectreBolt">
    <link rel="apple-touch-icon" href="/download.png">
    <link rel="preload" href="/ios-share.png" as="image">
    <style>
        :root {
            --ui-bg: rgba(0, 0, 0, 0.7);
            --accent: #0f4;
            --sprint: #0cf;
        }

        #portrait-warning {
            display: none; position: fixed; inset: 0; background: #222; z-index: 9999;
            color: white; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 20px;
        }

        body { 
            margin: 0; overflow: hidden; background: #111; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            touch-action: none; user-select: none; -webkit-user-select: none;
            width: 100vw; height: 100dvh; position: fixed;
        }

        @media screen and (orientation: portrait) {
            #portrait-warning {
                display: flex !important;
            }
        }


        canvas { display: block; }
        #killFeed {
            position: fixed;
            top: 80px;
            right: 15px;
            text-align: right;
            pointer-events: none;
            z-index: 100;
        }
        .kill-msg {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 14px;
            animation: fadeOut 4s forwards;
        }
        @keyframes fadeOut {
            0% { opacity: 1; transform: translateX(0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateX(20px); }
        }
        
        #nameScreen, #gameOver {
            position: fixed; inset: 0; background: #222; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        #nameScreen h1 { color: white; font-size: 56px; margin-bottom: 30px; letter-spacing: 5px; }
        #nameScreen input { 
            padding: 15px; font-size: 20px; border-radius: 5px; border: none; 
            width: 280px; text-align: center; outline: none;
        }
        #nameScreen button, #gameOver button { 
            margin-top: 25px; padding: 15px 50px; font-size: 22px; 
            background: var(--accent); border: none; cursor: pointer; 
            font-weight: bold; border-radius: 5px; transition: transform 0.1s;
        }

        
        #ui, #leaderboard {
            position: fixed; top: 15px; color: white;
            background: var(--ui-bg); padding: 15px; border-radius: 10px; 
            pointer-events: none; z-index: 10; font-size: 14px;
        }
        #ui { left: 15px; min-width: 160px; }
        #leaderboard { right: 15px; text-align: right; min-width: 140px; }

        .bar-bg { width: 100%; height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin-top: 5px; }
        #staminaBar { width: 100%; height: 100%; background: var(--sprint); transition: width 0.1s; }
        #timer { font-size: 22px; font-weight: bold; color: var(--accent); margin-bottom: 8px; }
        #score {
            font-size: 20px;
            color: var(--sprint);
            margin-top: 15px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
        }

        
        #mobileControls {
            display: none; position: fixed; inset: 0; z-index: 500; pointer-events: none;
        }
        @media (pointer: coarse) { #mobileControls { display: block; } }

        .joystick-base {
            position: absolute; bottom: 40px; left: 60px; width: 140px; height: 140px;
            background: rgba(255,255,255,0.1); border-radius: 50%; pointer-events: auto;
        }
        .joystick-knob {
            position: absolute; top: 45px; left: 45px; width: 50px; height: 50px;
            background: rgba(255,255,255,0.4); border-radius: 50%;
        }

        .action-btn {
            position: absolute; border-radius: 50%; display: flex; align-items: center; 
            justify-content: center; color: white; font-weight: bold; pointer-events: auto;
        }
        #sprintBtn {
            bottom: 40px; right: 40px; width: 80px; height: 80px;
            background: rgba(0, 150, 255, 0.6); border: 3px solid rgba(255,255,255,0.2);
            font-size: 14px;
        }

        
        #minimap-container {
            position: fixed; bottom: 20px; left: 20px; width: 140px; height: 140px;
            background: rgba(0, 0, 0, 0.6); border: 2px solid #555; border-radius: 8px;
            overflow: hidden; z-index: 5;
        }
        #minimap-canvas { display: block; }
        #mapToggle {
            display: none; position: fixed; bottom: 170px; left: 20px; padding: 8px 12px;
            background: var(--ui-bg); color: white; border: 1px solid #555;
            border-radius: 5px; font-size: 10px; pointer-events: auto; z-index: 10;
        }
        @media (pointer: coarse) { #mapToggle { display: block; } }

        #ios-prompt {
            display: none; position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%); width: 90%; max-width: 350px;
            background: white; color: black; padding: 15px; border-radius: 12px;
            z-index: 9999; box-shadow: 0 10px 25px rgba(0,0,0,0.5); font-size: 14px;
        }
        #ios-prompt .close-prompt {
            position: absolute; top: 5px; right: 10px; font-size: 20px; cursor: pointer;
        }
        #ios-prompt b { color: #007aff; } 
    </style>
</head>
<body>

    <div id="portrait-warning">
        <h2>PLEASE ROTATE TO LANDSCAPE</h2>
        <p>This game is best played in landscape mode.</p>
        <p>Tap to shoot when you enter</p>
    </div>
    
    <div id="ios-prompt">
        <span class="close-prompt" onclick="document.getElementById('ios-prompt').style.display='none'">&times;</span>
        <p style="margin: 0;">
            <b>Play Fullscreen:</b> Tap the <img src="ios-share.png" width="15" style="vertical-align: middle;"> button and select <b>"Add to Home Screen"</b>.
        </p>
    </div>

    <div id="nameScreen">
        <h1>SpectreBolt Arena</h1>
        <input type="text" id="nameInput" placeholder="NICKNAME" maxlength="12">
        <button id="startBtn">JOIN ARENA</button>
    </div>
    <div id="killFeed"></div>
    <div id="gameOver" style="display:none;">
        <h1 style="color: var(--accent);">ARENA CLOSED</h1>
        <div id="winnerList" style="font-size: 24px; text-align: center; color: white;"></div>
        <div id="score"></div>
        <button onclick="location.reload()">REMATCH</button>
    </div>

    <button id="mapToggle">HIDE MAP</button>
    <div id="minimap-container">
        <canvas id="minimap-canvas" width="140" height="140"></canvas>
    </div>

    <div id="ui">
        <div id="timer">TIME: 15:00</div>
        <div>HP: <span id="hpText">100</span> | Lives: <span id="livesText">3</span></div>
        <div class="bar-bg"><div id="staminaBar"></div></div>
    </div>

    <div id="leaderboard">
        <div style="border-bottom: 1px solid #555; margin-bottom: 5px; padding-bottom: 2px;"><b>LEADERBOARD</b></div>
        <div id="scoreList"></div>
    </div>

    <div id="mobileControls">
        <div id="moveJoystick" class="joystick-base">
            <div id="moveKnob" class="joystick-knob"></div>
        </div>
        <div id="shootJoystick" class="joystick-base" style="bottom: 40px;right: 60px;left: auto;display: none;">
            <div id="shootKnob" class="joystick-knob"></div>
        </div>
        <div id="sprintBtn" class="action-btn">RUN</div>
    </div>

    <canvas id="game"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io({ transports: ['websocket'], upgrade: false });
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const lerp = (a, b, t) => a + (b - a) * t;
        const SHOOT_INTERVAL=100;
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||(navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        const MAX_DIST = 50;
        const DEADZONE = 6;
        
        
        let lastMiniUpdate = 0;
        let myId, mapSize, walls = [];
        let players = {}, bots = {}, bullets = {}, matchTimer = 1200;
        let keys = {};
        let mouseAngle = 0;
        let isMobileSprinting = false;
        let joy = { active: false, startX: 0, startY: 0, id: null, x:0, y:0 };
        let shootJoy = {active:false, x:0, y:0, id:null}
        let camX=0; let camY=0;
        let moveTouchId = null;
        let personalBest = Number(localStorage.getItem("personalBest") || 0);
        let lastInput = null;
        let lastShootTime=0;
        

        
        window.addEventListener('load', () => {
            const isStandalone = window.navigator.standalone === true || window.matchMedia('(display-mode: standalone)').matches;
            if (isIOS && !isStandalone) {
                document.getElementById('ios-prompt').style.display = 'block';
            }
        });
        if (isIOS && 'ontouchstart' in window) {
            document.getElementById('shootJoystick').style.display = 'block';
        }



        async function requestFullScreen() {
            const el = document.documentElement;
            try {
                if (el.requestFullscreen) await el.requestFullscreen();
                else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
                if (screen.orientation && screen.orientation.lock) {
                    await screen.orientation.lock('landscape').catch(()=>{});
                }
            } catch (err) { console.log(err); }
        }

        function resizeCanvas(){
            canvas.width = window.innerWidth;
            canvas.height=window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        document.getElementById('startBtn').onclick = () => {
            requestFullScreen();
            const name = document.getElementById('nameInput').value;
            socket.emit('joinGame', { name: name || "Sniper" });
            document.getElementById('nameScreen').style.display = 'none';
        };

        
        const joyBase = document.getElementById('moveJoystick');
        const joyKnob = document.getElementById('moveKnob');

        const updateJoystick = (touch) => {
            const rect = joyBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;

            const maxDist = 45;
            const dist = Math.min(maxDist, Math.hypot(dx, dy));
            const angle = Math.atan2(dy, dx);

            joy.x = (Math.cos(angle) * dist) / maxDist;
            joy.y = (Math.sin(angle) * dist) / maxDist;

            const rawDist = Math.hypot(dx, dy);
            const deadzone = 8;

            if (rawDist < deadzone) {
                joy.x = 0;
                joy.y = 0;
            } else {
                const clamped = Math.min(maxDist, rawDist);
                joy.x = (dx / rawDist) * (clamped / maxDist);
                joy.y = (dy / rawDist) * (clamped / maxDist);
            }

            joyKnob.style.transform =`translate(${joy.x * maxDist}px, ${joy.y * maxDist}px)`;
        };

        function handleTapToShoot(touch) {
            if (isIOS) return;

            if (!players[myId] || players[myId].isSpectating) return;

            const angle = Math.atan2(touch.clientY - window.innerHeight / 2, touch.clientX - window.innerWidth / 2);

            mouseAngle = angle;
            socket.emit('fire', { angle });
        }
        if (!isIOS) {
            canvas.addEventListener('touchstart', e => {
                if (e.target !== canvas) return;

                handleTapToShoot(e.changedTouches[0]);
            }, { passive: false });
        }




        joyBase.addEventListener('touchstart', e => {
            const t = e.changedTouches[0];
            joy.active = true;
            joy.id = t.identifier;

            joy.startX = t.clientX;
            joy.startY = t.clientY;

            joyBase.style.left = (joy.startX - 70) + "px";
            joyBase.style.top  = (joy.startY - 70) + "px";

            joyKnob.style.transform = "translate(0,0)";
            e.preventDefault();
        }, { passive: false });


        joyBase.addEventListener('touchmove', e => {
            for (const t of e.changedTouches) {
                if (t.identifier !== joy.id) continue;

                let dx = t.clientX - joy.startX;
                let dy = t.clientY - joy.startY;

                const dist = Math.hypot(dx, dy);
                const clamped = Math.min(dist, MAX_DIST);
                const angle = Math.atan2(dy, dx);

                if (dist < DEADZONE) {
                    joy.x = 0;
                    joy.y = 0;
                    joyKnob.style.transform = "translate(0,0)";
                    return;
                }

                joy.x = Math.cos(angle) * (clamped / MAX_DIST);
                joy.y = Math.sin(angle) * (clamped / MAX_DIST);

                joyKnob.style.transform =`translate(${joy.x * MAX_DIST}px, ${joy.y * MAX_DIST}px)`;

                e.preventDefault();
            }
        }, { passive: false });


        joyBase.addEventListener('touchend', e => {
            for (const t of e.changedTouches) {
                if (t.identifier !== joy.id) continue;

                joy.active = false;
                joy.id = null;
                joy.x = 0;
                joy.y = 0;

                joyKnob.style.transform = "translate(0,0)";
            }
        }, { passive: false });

        const shootBase = document.getElementById('shootJoystick');
        const shootKnob = document.getElementById('shootKnob');

        shootBase.addEventListener('touchstart', e => {
            const t = e.changedTouches[0];
            shootJoy.active = true;
            shootJoy.id = t.identifier;
            shootKnob.style.transform = "translate(0,0)";
            e.preventDefault();
        }, { passive: false });

        shootBase.addEventListener('touchmove', e => {
            for (const t of e.changedTouches) {
                if (t.identifier !== shootJoy.id) continue;

                const rect = shootBase.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;

                const dx = t.clientX - cx;
                const dy = t.clientY - cy;

                const dist = Math.hypot(dx, dy);
                const clamped = Math.min(dist, MAX_DIST);

                if (dist < DEADZONE) {
                    shootJoy.x = 0;
                    shootJoy.y = 0;
                    shootKnob.style.transform = "translate(0,0)";
                    return;
                }

                shootJoy.x = dx / dist;
                shootJoy.y = dy / dist;

                mouseAngle = Math.atan2(shootJoy.y, shootJoy.x);

                shootKnob.style.transform =`translate(${shootJoy.x * clamped}px, ${shootJoy.y * clamped}px)`;

                e.preventDefault();
            }
        }, { passive: false });


        shootBase.addEventListener('touchend', e => {
            for (const t of e.changedTouches) {
                if (t.identifier !== shootJoy.id) continue;

                shootJoy.active = false;
                shootJoy.id = null;
                shootJoy.x = 0;
                shootJoy.y = 0;
                shootKnob.style.transform = "translate(0,0)";
            }
        }, { passive: false });


        document.getElementById('sprintBtn').addEventListener('touchstart', (e) => { e.preventDefault(); isMobileSprinting = true; });
        document.getElementById('sprintBtn').addEventListener('touchend', (e) => { e.preventDefault(); isMobileSprinting = false; });

        
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => {
            if (!joy.active) {
                mouseAngle = Math.atan2(e.clientY - canvas.height/2, e.clientX - canvas.width/2);
            }
        });
        window.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'CANVAS') return;
            const me = players[myId];
            if (!me || me.isSpectating) return;

            socket.emit('fire', { angle: mouseAngle });
        });


        
        socket.on('init', d => { 
            myId = d.id; mapSize = d.mapSize; walls = d.walls; 
            players[myId] = {
                id:myId,
                x:d.spawnX || mapSize/2,
                y:d.spawnY || mapSize/2,
                angle:0,
                hp:100,
                stamina:100,
                lives:3,
                score:0,
                name:document.getElementById('nameInput').value || "Sniper",
                color:null,
                isSpectating:false,
                spawnProtected:true
            };
            if (players[myId]) { camX = players[myId].x; camY = players[myId].y; }
        });
        socket.on('killEvent', (data) => {
            const feed = document.getElementById('killFeed');
            const msg = document.createElement('div');
            msg.className='kill-msg';
            msg.innerHTML = `<span style="color:var(--accent)">${data.shooter}</span> killed ${data.victim}`;
            if (feed.children.length > 5) feed.removeChild(feed.firstChild);
            else {feed.appendChild(msg);}
            setTimeout(() => msg.remove(), 4000);
        });
        socket.on('state', s => {
            matchTimer = s.matchTimer;
            bullets = s.bullets;
            bots = s.bots;

    
            Object.entries(s.players).forEach(([id, p]) => {
                if (!players[id]) players[id] = p;
                else Object.assign(players[id], p);
            });

    
            Object.keys(players).forEach(id => {
                if (!s.players[id]) delete players[id];
            });

    
            if (players[myId] && s.players[myId]) {
                players[myId].hp = s.players[myId].hp;
                players[myId].lives = s.players[myId].lives;
                players[myId].score = s.players[myId].score;
                players[myId].isSpectating = s.players[myId].isSpectating;
                players[myId].spawnProtected = s.players[myId].spawnProtected;
                players[myId].stamina = s.players[myId].stamina;
            }

            const all = [...Object.values(players), ...Object.values(bots)].sort((a, b) => b.score - a.score).slice(0, 5);

            document.getElementById('scoreList').innerHTML =all.map(p => `<div>${p.name}: ${p.score}</div>`).join('');
        });


        socket.on('respawned', (data)=>{ camX = data.x; camY = data.y; });
        socket.on('errorMsg', (msg) => { alert(msg); document.getElementById('nameScreen').style.display = 'flex'; });
        socket.on('matchReset', ()=>{ document.getElementById('gameOver').style.display='none'; });


        setInterval(() => {
            if (!shootJoy.active) return;

            const me = players[myId];
            if (!me || me.isSpectating) return;

            const now = performance.now();
            if (now - lastShootTime < SHOOT_INTERVAL) return;

            if (shootJoy.x === 0 && shootJoy.y === 0) return;

            lastShootTime = now;

            const angle = Math.atan2(shootJoy.y, shootJoy.x);
            mouseAngle = angle;

            socket.emit('fire', { angle });
        }, 1000 / 60);

        setInterval(() => {
            const me = players[myId];
            if (!me || matchTimer <= 0) return;

            const isSprinting = keys['ShiftLeft'] || keys['ShiftRight'] || isMobileSprinting;
            let dx = 0, dy = 0;

            if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) dx += 1;

            if (joy.active) {
                dx = joy.x;
                dy = joy.y;
            }
            if (me.isSpectating) {
                dx = joy.x || dx;
                dy = joy.y || dy;
            }

            let aimingAngle = mouseAngle;
            if (joy.active && (joy.x !== 0 || joy.y !== 0)) {
                aimingAngle = Math.atan2(joy.y, joy.x);
            }
            const quantAngle = Math.round(aimingAngle * 100) / 100;
            const input = { moveX:dx, moveY:dy, sprint:isSprinting, angle: quantAngle };
            if (me.isSpectating ||!lastInput ||input.moveX !== lastInput.moveX ||input.moveY !== lastInput.moveY ||input.sprint !== lastInput.sprint ||input.angle !== lastInput.angle) {
                socket.emit('input', input);
                lastInput = input;
            }

        }, 1000/60);

        function clientCollidesWithWall(x, y, r = 20) {
            if (x < r || y < r || x > mapSize - r || y > mapSize - r) return true;
            return walls.some(w => x + r > w.x && x - r < w.x + w.w && y + r > w.y && y - r < w.y + w.h);
        }

        function drawEntity(p, color, label, isMe) {
            ctx.save();
            if (p.isSpectating) ctx.globalAlpha = 0.5;
            ctx.translate(p.x, p.y);
            if (p.spawnProtected && !p.isSpectating) {
                ctx.beginPath(); ctx.arc(0, 0, 28, 0, Math.PI * 2);
                ctx.strokeStyle = "#0cf"; ctx.lineWidth = 3; ctx.setLineDash([5, 5]); ctx.stroke();
                ctx.setLineDash([]);
            }
            if (!p.isSpectating) {
                ctx.fillStyle = "#333"; ctx.fillRect(-20, -45, 40, 6);
                ctx.fillStyle = p.hp > 30 ? "#0f4" : "#f22"; ctx.fillRect(-20, -45, (p.hp/100) * 40, 6);
            }
            ctx.save(); ctx.rotate(p.angle);
            ctx.fillStyle = color; ctx.strokeStyle = "#000"; ctx.lineWidth = 3;
            ctx.fillRect(0, -6, 32, 12); ctx.strokeRect(0, -6, 32, 12);
            ctx.restore();
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2);
            ctx.fillStyle = color; ctx.fill();
            ctx.strokeStyle = isMe ? "#fff" : "#000"; ctx.lineWidth = isMe ? 4 : 3; ctx.stroke();
            ctx.fillStyle = "white"; ctx.globalAlpha = 1; ctx.font = "bold 14px Arial"; ctx.textAlign = "center";
            ctx.fillText((p.isSpectating ? "[GHOST] " : "") + label, 0, -55);
            ctx.restore();
        }

        const miniCanvas = document.getElementById('minimap-canvas');
        const miniCtx = miniCanvas.getContext('2d');
        const mapToggle = document.getElementById('mapToggle');
        const miniContainer = document.getElementById('minimap-container');

        mapToggle.onclick = () => {
            const hidden = miniContainer.style.display === 'none';
            miniContainer.style.display = hidden ? 'block' : 'none';
            mapToggle.innerText = hidden ? 'HIDE MAP' : 'SHOW MAP';
        };

        function drawMinimap() {
            miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
            const scale = miniCanvas.width / mapSize;
            miniCtx.fillStyle = "#444";
            walls.forEach(w => miniCtx.fillRect(w.x * scale, w.y * scale, w.w * scale, w.h * scale));
            Object.values(bots).forEach(b => {
                miniCtx.fillStyle = "red"; miniCtx.beginPath();
                miniCtx.arc(b.x * scale, b.y * scale, 3, 0, Math.PI * 2); miniCtx.fill();
            });
            Object.values(players).forEach(p => {
                if (p.id !== myId) {
                    miniCtx.fillStyle = p.isSpectating ? "rgba(255,255,255,0.3)" : "white";
                    miniCtx.beginPath(); miniCtx.arc(p.x * scale, p.y * scale, 2, 0, Math.PI * 2); miniCtx.fill();
                }
            });
            const me = players[myId];
            if (me) {
                miniCtx.fillStyle = "#0f4"; miniCtx.beginPath();
                miniCtx.arc(me.x * scale, me.y * scale, 4, 0, Math.PI * 2); miniCtx.fill();
            }
        }

        function draw(){
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            if (!players || !players[myId]) {
                return;
            }

            ctx.setTransform(1, 0, 0, 1, 0, 0);

            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const me = players[myId];
            if (!me || !Number.isFinite(me.x) || !Number.isFinite(me.y)) {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = "#111";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                return;
            }

            if (!Number.isFinite(camX) || !Number.isFinite(camY)) {
                camX = me.x;
                camY = me.y;
            }

            ctx.save();
            const CAM_LERP = 0.22;
            camX += (me.x - camX) * CAM_LERP;
            camY += (me.y - camY) * CAM_LERP;

            if (!Number.isFinite(camX) || !Number.isFinite(camY)) {
                camX = me.x;
                camY = me.y;
            }

            ctx.translate(canvas.width / 2 - camX, canvas.height / 2 - camY);

            ctx.fillStyle = "#006666";
            ctx.fillRect(0, 0, mapSize, mapSize);

            ctx.strokeStyle = "rgba(0,0,0,0.2)";
            for (let i = 0; i <= mapSize; i += 100) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, mapSize); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(mapSize, i); ctx.stroke();
            }

            walls.forEach(w => {
                ctx.fillStyle = "#333";
                ctx.fillRect(w.x, w.y, w.w, w.h);
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 4;
                ctx.strokeRect(w.x, w.y, w.w, w.h);
            });
            Object.values(bullets).forEach(b => {
                if (
                    Math.abs(b.x - camX) > canvas.width ||
                    Math.abs(b.y - camY) > canvas.height
                ) return;

                ctx.beginPath();
                ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
                ctx.fill();
            });


            Object.values(bots).forEach(b => {
                b.renderX = lerp(b.renderX || b.x, b.x, 0.15);
                b.renderY = lerp(b.renderY || b.y, b.y, 0.15);
                drawEntity({ ...b, x: b.renderX, y: b.renderY }, b.color, b.name, false);
            });

            Object.values(players).forEach(p => {
                if (p.id === myId) return;
                p.renderX = lerp(p.renderX || p.x, p.x, 0.15);
                p.renderY = lerp(p.renderY || p.y, p.y, 0.15);
                drawEntity({ ...p, x: p.renderX, y: p.renderY }, p.color, p.name, false);
            });

            drawEntity(me, me.color, me.name, true);
            ctx.restore();

            document.getElementById('hpText').innerText = Math.ceil(me.hp);
            document.getElementById('livesText').innerText = me.lives;
            document.getElementById('staminaBar').style.width = me.stamina + "%";

            const mins = Math.floor(matchTimer / 60);
            const secs = Math.floor(matchTimer % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `TIME: ${mins}:${secs}`;

            if (matchTimer <= 0) {
                document.getElementById('gameOver').style.display = 'flex';
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = "#111";
                ctx.fillRect(0, 0, canvas.width, canvas.height)
                drawMinimap();
                if (me.score > personalBest) {
                    personalBest = me.score;
                    localStorage.setItem("personalBest", personalBest);
                    document.getElementById('score').innerHTML =`NEW PERSONAL BEST: ${me.score}`;
                }
                else{
                    document.getElementById('score').innerHTML =`SCORE: ${me.score}<br>PERSONAL BEST: ${personalBest}`;
                }
                return;
            }
            if (Date.now() - lastMiniUpdate > 200) {
                drawMinimap();
                lastMiniUpdate = Date.now();
            }

            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        function renderLoop() {
            draw();
            requestAnimationFrame(renderLoop);
        }
        requestAnimationFrame(renderLoop);
    </script>
</body>
</html>