<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>SpectreBolt Arena</title>
    <link rel="favicon" type="image/png" href="download.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SpectreBolt">
    <link rel="apple-touch-icon" href="download.png">
    <style>
        :root {
            --ui-bg: rgba(0, 0, 0, 0.7);
            --accent: #0f4;
            --sprint: #0cf;
        }

        /* Landscape Orientation Helper */
        @media screen and (orientation: portrait) {
            #portrait-warning {
                display: flex !important;
            }
        }

        #portrait-warning {
            display: none; position: fixed; inset: 0; background: #222; z-index: 9999;
            color: white; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 20px;
        }

        body { 
            margin: 0; overflow: hidden; background: #111; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            touch-action: none; user-select: none; -webkit-user-select: none;
            width: 100vw; height: 100dvh; position: fixed;
        }

        canvas { display: block; }

        /* Screens */
        #nameScreen, #gameOver {
            position: fixed; inset: 0; background: #222; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        #nameScreen h1 { color: white; font-size: 56px; margin-bottom: 30px; letter-spacing: 5px; }
        #nameScreen input { 
            padding: 15px; font-size: 20px; border-radius: 5px; border: none; 
            width: 280px; text-align: center; outline: none;
        }
        #nameScreen button, #gameOver button { 
            margin-top: 25px; padding: 15px 50px; font-size: 22px; 
            background: var(--accent); border: none; cursor: pointer; 
            font-weight: bold; border-radius: 5px; transition: transform 0.1s;
        }

        /* HUD Elements */
        #ui, #leaderboard {
            position: fixed; top: 15px; color: white;
            background: var(--ui-bg); padding: 15px; border-radius: 10px; 
            pointer-events: none; z-index: 10; font-size: 14px;
        }
        #ui { left: 15px; min-width: 160px; }
        #leaderboard { right: 15px; text-align: right; min-width: 140px; }

        .bar-bg { width: 100%; height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin-top: 5px; }
        #staminaBar { width: 100%; height: 100%; background: var(--sprint); transition: width 0.1s; }
        #timer { font-size: 22px; font-weight: bold; color: var(--accent); margin-bottom: 8px; }

        /* Mobile Controls */
        #mobileControls {
            display: none; position: fixed; inset: 0; z-index: 500; pointer-events: none;
        }
        @media (pointer: coarse) { #mobileControls { display: block; } }

        .joystick-base {
            position: absolute; bottom: 40px; left: 60px; width: 140px; height: 140px;
            background: rgba(255,255,255,0.1); border-radius: 50%; pointer-events: auto;
        }
        .joystick-knob {
            position: absolute; top: 45px; left: 45px; width: 50px; height: 50px;
            background: rgba(255,255,255,0.4); border-radius: 50%;
        }

        #shootJoystick {
            position: absolute; bottom: 40px; right: 60px; width: 140px; height: 140px;
            background: rgba(255,50,50,0.1); border-radius: 50%; pointer-events: auto;
        }

        #shootKnob {
            position: absolute; top: 45px; left: 45px; width: 50px; height: 50px;
            background: rgba(255,50,50,0.4); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 10px;
        }

        .action-btn {
            position: absolute; border-radius: 50%; display: flex; align-items: center; 
            justify-content: center; color: white; font-weight: bold; pointer-events: auto;
        }
        #sprintBtn {
            bottom: 190px; right: 60px; width: 65px; height: 65px;
            background: rgba(0, 150, 255, 0.6); border: 3px solid rgba(255,255,255,0.2);
            font-size: 12px;
        }

        /* Minimap Styles */
        #minimap-container {
            position: fixed; bottom: 20px; left: 20px; width: 140px; height: 140px;
            background: rgba(0, 0, 0, 0.6); border: 2px solid #555; border-radius: 8px;
            overflow: hidden; z-index: 5;
        }
        #minimap-canvas { display: block; }
        #mapToggle {
            display: none; position: fixed; bottom: 170px; left: 20px; padding: 8px 12px;
            background: var(--ui-bg); color: white; border: 1px solid #555;
            border-radius: 5px; font-size: 10px; pointer-events: auto; z-index: 10;
        }
        @media (pointer: coarse) { #mapToggle { display: block; } }
        #ios-prompt {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 350px;
            background: white;
            color: black;
            padding: 15px;
            border-radius: 12px;
            z-index: 9999;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            font-size: 14px;
        }
        #ios-prompt .close-prompt {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 20px;
            cursor: pointer;
        }
        #ios-prompt b { color: #007aff; } 
    </style>
</head>
<body>

    <div id="portrait-warning">
        <h2>PLEASE ROTATE TO LANDSCAPE</h2>
        <p>This game is best played in landscape mode.</p>
    </div>
    <div id="ios-prompt">
        <span class="close-prompt" onclick="document.getElementById('ios-prompt').style.display='none'">&times;</span>
        <p style="margin: 0;">
            <b>Play Fullscreen:</b> Tap the <img src="https://upload.wikimedia.org/wikipedia/commons/d/d5/Apple_Share_Icon.svg" width="15" style="vertical-align: middle;"> button below and select <b>"Add to Home Screen"</b>.
        </p>
    </div>

    <div id="nameScreen">
        <h1>SpectreBolt Arena</h1>
        <input type="text" id="nameInput" placeholder="NICKNAME" maxlength="12">
        <button id="startBtn">JOIN ARENA</button>
    </div>

    <div id="gameOver" style="display:none;">
        <h1 style="color: var(--accent);">ARENA CLOSED</h1>
        <div id="winnerList" style="font-size: 24px; text-align: center; color: white;"></div>
        <button onclick="location.reload()">REMATCH</button>
    </div>

    <button id="mapToggle">HIDE MAP</button>
    <div id="minimap-container">
        <canvas id="minimap-canvas" width="140" height="140"></canvas>
    </div>

    <div id="ui">
        <div id="timer">TIME: 20:00</div>
        <div>HP: <span id="hpText">100</span> | Lives: <span id="livesText">3</span></div>
        <div class="bar-bg"><div id="staminaBar"></div></div>
    </div>

    <div id="leaderboard">
        <div style="border-bottom: 1px solid #555; margin-bottom: 5px; padding-bottom: 2px;"><b>LEADERBOARD</b></div>
        <div id="scoreList"></div>
    </div>

    <div id="mobileControls">
        <div id="moveJoystick" class="joystick-base">
            <div id="moveKnob" class="joystick-knob"></div>
        </div>
        <div id="shootJoystick">
            <div id="shootKnob">FIRE</div>
        </div>
        <div id="sprintBtn" class="action-btn">RUN</div>
    </div>

    <canvas id="game"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io({ transports: ['websocket'], upgrade: false });
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const lerp = (a, b, t) => a + (b - a) * t;

        let myId, mapSize, walls = [];
        let players = {}, bots = {}, bullets = {}, matchTimer = 1200;
        let keys = {};
        let mouseAngle = 0;
        let isMobileSprinting = false;
        let joy = { active: false, x: 0, y: 0 };
        let camX=0; let camY=0;
        let fireInterval = null;

        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isStandalone = window.navigator.standalone === true || window.matchMedia('(display-mode: standalone)').matches;

        if (isIOS && !isStandalone) {
            document.getElementById('ios-prompt').style.display = 'block';
        }
        async function requestFullScreen() {
            const el = document.documentElement;
            try {
                if (el.requestFullscreen) {
                    await el.requestFullscreen();
                } else if (el.webkitRequestFullscreen) {
                    await el.webkitRequestFullscreen();
                }

        
                if (screen.orientation && screen.orientation.lock) {
                    await screen.orientation.lock('landscape');
                }
            } catch (err) {
                console.log("Orientation/Fullscreen error: ", err);
            }
        }

        window.addEventListener('resize', () => {
            setTimeout(() => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                window.scrollTo(0, 0);
            }, 100);
        });
        window.dispatchEvent(new Event('resize'));
        
        document.getElementById('startBtn').onclick = () => {
            requestFullScreen(); // Triggered by user click
            const name = document.getElementById('nameInput').value;
            socket.emit('joinGame', { name: name || "Sniper" });
            document.getElementById('nameScreen').style.display = 'none';
        };

        // Input Listeners
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => {
            if (!joy.active) {
                mouseAngle = Math.atan2(e.clientY - canvas.height/2, e.clientX - canvas.width/2);
            }
        });
        window.addEventListener('mousedown', () => {
            if (players[myId] && !players[myId].isSpectating) socket.emit('fire', { angle: mouseAngle });
        });

        // Mobile Movement Joystick
        const joyBase = document.getElementById('moveJoystick');
        const joyKnob = document.getElementById('moveKnob');

        const updateJoystick = (e) => {
            const touch = e.touches[0];
            const rect = joyBase.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.min(50, Math.hypot(dx, dy));
            const angle = Math.atan2(dy, dx);
            joy.x = (Math.cos(angle) * dist) / 50;
            joy.y = (Math.sin(angle) * dist) / 50;
            joy.active = true;
            joyKnob.style.transform = `translate(${joy.x * 45}px, ${joy.y * 45}px)`;
        };

        joyBase.addEventListener('touchstart', e => { e.preventDefault(); updateJoystick(e); });
        joyBase.addEventListener('touchmove', e => { e.preventDefault(); updateJoystick(e); });
        joyBase.addEventListener('touchend', () => {
            joy.active = false; joy.x = 0; joy.y = 0;
            joyKnob.style.transform = `translate(0,0)`;
        });

        // Mobile Aim/Shoot Joystick
        const shootJoy = document.getElementById('shootJoystick');
        const shootKnob = document.getElementById('shootKnob');

        const updateShootJoystick = (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = shootJoy.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.min(50, Math.hypot(dx, dy));
            const angle = Math.atan2(dy, dx);
            
            mouseAngle = angle;
            shootKnob.style.transform = `translate(${Math.cos(angle) * dist}px, ${Math.sin(angle) * dist}px)`;

            if (!fireInterval) {
                fireInterval = setInterval(() => {
                    if (players[myId] && !players[myId].isSpectating) socket.emit('fire', { angle: mouseAngle });
                }, 200);
            }
        };

        shootJoy.addEventListener('touchstart', updateShootJoystick);
        shootJoy.addEventListener('touchmove', updateShootJoystick);
        shootJoy.addEventListener('touchend', () => {
            clearInterval(fireInterval);
            fireInterval = null;
            shootKnob.style.transform = `translate(0,0)`;
        });

        document.getElementById('sprintBtn').addEventListener('touchstart', (e) => { e.preventDefault(); isMobileSprinting = true; });
        document.getElementById('sprintBtn').addEventListener('touchend', (e) => { e.preventDefault(); isMobileSprinting = false; });

        // Networking & Stamina
        socket.on('init', d => { 
            myId = d.id; mapSize = d.mapSize; walls = d.walls; 
            if(players[myId]) { camX = players[myId].x; camY = players[myId].y; }
        });

        socket.on('state', s => { 
            const myLocalX = players[myId]?.x;
            const myLocalY = players[myId]?.y;
            const myLocalStamina = players[myId]?.stamina;

            players = s.players; bots = s.bots; bullets = s.bullets; matchTimer = s.matchTimer;

            if (players[myId] && !players[myId].isSpectating) {
                players[myId].x = myLocalX || players[myId].x;
                players[myId].y = myLocalY || players[myId].y;
                const serverStamina=s.players[myId].stamina;
                if (Math.abs(players[myId].stamina - serverStamina) > 5) {
                  players[myId].stamina = serverStamina;
                }
            }
        });

        socket.on('respawned', (data)=>{ camX = data.x; camY = data.y; });
        socket.on('errorMsg', (msg) => { alert(msg); document.getElementById('nameScreen').style.display = 'flex'; });
        socket.on('matchReset', ()=>{ document.getElementById('gameOver').style.display='none'; });

        // Game Loop
        setInterval(() => {
            const me = players[myId];
            if (!me || matchTimer <= 0) return;

            const isSprinting = keys['ShiftLeft'] || keys['ShiftRight'] || isMobileSprinting;
            let speed = me.isSpectating ? 8.0 : ((isSprinting && me.stamina > 5) ? 9.2 : 5.8);
            let dx = 0, dy = 0;

            if (keys['KeyW'] || keys['ArrowUp']) dy -= speed;
            if (keys['KeyS'] || keys['ArrowDown']) dy += speed;
            if (keys['KeyA'] || keys['ArrowLeft']) dx -= speed;
            if (keys['KeyD'] || keys['ArrowRight']) dx += speed;

            if (joy.active) { dx = joy.x * speed; dy = joy.y * speed; }

            if (dx !== 0 || dy !== 0) {
                if (me.isSpectating) {
                    me.x += dx;
                    me.y += dy;
                }else{
                    if (!clientCollidesWithWall(me.x + dx, me.y)) me.x += dx;
                    if (!clientCollidesWithWall(me.x, me.y + dy)) me.y += dy;
                    if (isSprinting && me.stamina>0) me.stamina = Math.max(0, me.stamina - 1.5);
                    else{me.stamina = Math.min(100, me.stamina + 0.5);}
                }
                
            }
            else{me.stamina = Math.min(100, me.stamina + 0.7);}

            socket.emit('update', { x: me.x, y: me.y, angle: mouseAngle, stamina: me.stamina });
        }, 1000/60);

        function clientCollidesWithWall(x, y, r = 20) {
            if (x < r || y < r || x > mapSize - r || y > mapSize - r) return true;
            return walls.some(w => x + r > w.x && x - r < w.x + w.w && y + r > w.y && y - r < w.y + w.h);
        }

        function drawEntity(p, color, label, isMe) {
            ctx.save();
            if (p.isSpectating) ctx.globalAlpha = 0.5;
            ctx.translate(p.x, p.y);
            if (p.spawnProtected && !p.isSpectating) {
                ctx.beginPath(); ctx.arc(0, 0, 28, 0, Math.PI * 2);
                ctx.strokeStyle = "#0cf"; ctx.lineWidth = 3; ctx.setLineDash([5, 5]); ctx.stroke();
                ctx.setLineDash([]);
            }
            if (!p.isSpectating) {
                ctx.fillStyle = "#333"; ctx.fillRect(-20, -45, 40, 6);
                ctx.fillStyle = p.hp > 30 ? "#0f4" : "#f22"; ctx.fillRect(-20, -45, (p.hp/100) * 40, 6);
            }
            ctx.save(); ctx.rotate(p.angle);
            ctx.fillStyle = color; ctx.strokeStyle = "#000"; ctx.lineWidth = 3;
            ctx.fillRect(0, -6, 32, 12); ctx.strokeRect(0, -6, 32, 12);
            ctx.restore();
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2);
            ctx.fillStyle = color; ctx.fill();
            ctx.strokeStyle = isMe ? "#fff" : "#000"; ctx.lineWidth = isMe ? 4 : 3; ctx.stroke();
            ctx.fillStyle = "white"; ctx.globalAlpha = 1; ctx.font = "bold 14px Arial"; ctx.textAlign = "center";
            ctx.fillText((p.isSpectating ? "[GHOST] " : "") + label, 0, -55);
            ctx.restore();
        }

        const miniCanvas = document.getElementById('minimap-canvas');
        const miniCtx = miniCanvas.getContext('2d');
        const mapToggle = document.getElementById('mapToggle');
        const miniContainer = document.getElementById('minimap-container');

        mapToggle.onclick = () => {
            const hidden = miniContainer.style.display === 'none';
            miniContainer.style.display = hidden ? 'block' : 'none';
            mapToggle.innerText = hidden ? 'HIDE MAP' : 'SHOW MAP';
        };

        function drawMinimap() {
            miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
            const scale = miniCanvas.width / mapSize;
            miniCtx.fillStyle = "#444";
            walls.forEach(w => miniCtx.fillRect(w.x * scale, w.y * scale, w.w * scale, w.h * scale));
            Object.values(bots).forEach(b => {
                miniCtx.fillStyle = "red"; miniCtx.beginPath();
                miniCtx.arc(b.x * scale, b.y * scale, 3, 0, Math.PI * 2); miniCtx.fill();
            });
            Object.values(players).forEach(p => {
                if (p.id !== myId) {
                    miniCtx.fillStyle = p.isSpectating ? "rgba(255,255,255,0.3)" : "white";
                    miniCtx.beginPath(); miniCtx.arc(p.x * scale, p.y * scale, 2, 0, Math.PI * 2); miniCtx.fill();
                }
            });
            const me = players[myId];
            if (me) {
                miniCtx.fillStyle = "#0f4"; miniCtx.beginPath();
                miniCtx.arc(me.x * scale, me.y * scale, 4, 0, Math.PI * 2); miniCtx.fill();
            }
        }

        function draw() {
            ctx.fillStyle = "#111"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            const me = players[myId];
            if (!me) { requestAnimationFrame(draw); return; }

            ctx.save();
            camX+=(me.x-camX)*0.10; camY+=(me.y-camY)*0.10;
            ctx.translate(canvas.width/2 - camX, canvas.height/2 - camY);

            ctx.fillStyle = "#006666"; ctx.fillRect(0, 0, mapSize, mapSize);
            ctx.strokeStyle = "rgba(0,0,0,0.2)";
            for(let i=0; i<=mapSize; i+=100) {
                ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,mapSize); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(mapSize,i); ctx.stroke();
            }

            walls.forEach(w => {
                ctx.fillStyle = "#333"; ctx.fillRect(w.x, w.y, w.w, w.h);
                ctx.strokeStyle = "#000"; ctx.lineWidth = 4; ctx.strokeRect(w.x, w.y, w.w, w.h);
            });

            Object.values(bullets).forEach(b => {
                ctx.fillStyle = "yellow"; ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI*2); ctx.fill();
            });

            Object.values(bots).forEach(b => {
                b.renderX = lerp(b.renderX || b.x, b.x, 0.15); b.renderY = lerp(b.renderY || b.y, b.y, 0.15);
                drawEntity({ ...b, x: b.renderX, y: b.renderY }, b.color, b.name, false);
            });
            Object.values(players).forEach(p => {
                if (p.id === myId) return;
                p.renderX = lerp(p.renderX || p.x, p.x, 0.15); p.renderY = lerp(p.renderY || p.y, p.y, 0.15);
                drawEntity({ ...p, x: p.renderX, y: p.renderY }, p.color, p.name, false);
            });
            
            drawEntity(me, me.color, me.name, true);
            ctx.restore();

            document.getElementById('hpText').innerText = Math.ceil(me.hp);
            document.getElementById('livesText').innerText = me.lives;
            document.getElementById('staminaBar').style.width = me.stamina + "%";
            
            const mins = Math.floor(matchTimer / 60);
            const secs = Math.floor(matchTimer % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `TIME: ${mins}:${secs}`;
            
            const all = [...Object.values(players), ...Object.values(bots)].sort((a,b) => b.score - a.score).slice(0,5);
            document.getElementById('scoreList').innerHTML = all.map(p => `<div>${p.name}: ${p.score}</div>`).join('');

            if (matchTimer <= 0) {
                document.getElementById('gameOver').style.display = 'flex';
                const high = Math.max(...[...Object.values(players), ...Object.values(bots)].map(e => e.score));
                const winners = [...Object.values(players), ...Object.values(bots)].filter(e => e.score === high);
                document.getElementById('winnerList').innerHTML = `High Score: ${high}<br>` + winners.map(w => w.name).join(', ');
                return;
            }
            drawMinimap();
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>