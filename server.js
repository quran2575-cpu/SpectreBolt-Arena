/*
 * Spectrebolt Arena - 2D Multiplayer Shooter Game Server-Side
 * Copyright (C) 2026 Saif Kayyali
 * GNU GPLv3
 */

const express = require('express');
const http = require('http');
const path = require('path');
const { Server } = require('socket.io');

const app = express();

app.use((req, res, next) => {
  if (req.url === '/robots.txt' || req.url === '/sitemap.xml') {
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
  }
  next();
});

app.get('/sitemap.xml', (req, res) => {
    const today = new Date().toISOString().split('T')[0];
    const urls = [
        { loc: 'https://spectrebolt-arena-9xk4.onrender.com', lastmod: today },
    ];

    let xml = `<?xml version="1.0" encoding="UTF-8"?>\n`;
    xml += `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n`;

    urls.forEach(u => {
        xml += `  <url>\n`;
        xml += `    <loc>${u.loc}</loc>\n`;
        xml += `    <lastmod>${u.lastmod}</lastmod>\n`;
        xml += `    <priority>1.0</priority>\n`;
        xml += `  </url>\n`;
    });

    xml += `</urlset>`;

    res.header('Content-Type', 'application/xml');
    res.send(xml);
});

app.use(express.static(path.join(__dirname, 'public')));

const server = http.createServer(app);
const io = new Server(server);

const PORT = process.env.PORT || 10000;

const activeRematches = new Set();
const MAP_SIZE = 2000;
const TICK_RATE = 1000 / 30;
const BASE_SPEED = 4.6;
const SPRINT_SPEED = 6.8;
const ENTITY_RADIUS = 18;
const MAX_PLAYERS=10;
const JOIN_CUTOFF_SECONDS=5*60;
const BULLET_LIFETIME = 1200;
const MAX_BULLETS=60;
const BULLET_RADIUS = 4;
const NET_TICK_IDLE = 1000 / 10;
const NET_TICK_ACTIVE = 1000 / 15;

// Note: Some bans are intentionally broad to prevent common abuse patterns:
// - mom/dad/mother/father/sister/brother/baby: harassment & sexual taunts
// - twin: Twin Towers references
// - hog: hogtie abuse
// - nigg: we know why
// - didd: diddy, diddle, diddler, etc.

const BANNED_WORDS = ['fuck','ass','asshole','douchebag','twat','groom','badass','sex','seg','penis','vagin','molest','anal','kus','sharmoot','khara','ukht','akh','abo','umm','anus','virgin','suck','blow','tit','oral','rim','69','zinji','breast','brest','zib','uterus','dumbass','boob','testi','balls','nut','egg','shit', 'nigg', 'bitch', 'slut', 'nazi', 'hitler', 'milf', 'cunt', 'retard', 'dick', 'didd', 'epstein', 'rape', 'pedo', 'rapis','porn','mussolini','musolini','stalin','trump','cock', 'israel','genocide','homicide','suicide','genocidal','suicidal','homicidal','hog','pussy','twin','9/11','murder','mom','dad','mother','father','sister','brother','goy','faggot','fagot','asshole','piss','negro','bastard','nipp','vulva','sperm','slave','bend','racial','racist','prostitute','prick','orgas','orgie','orgi','orge','mastur','masterb','jackass','horny','handjob','cum','finger','fetish','ejac','devil','demon','crotch','whore','hoe','clit','cocaine','coke','drug','dealer','weed','butt','bang','child','bond','meat','babe','baby'];
const WORD_ONLY_BANS = ['ass'];

const SAFE_SUBSTRING_BANS = ['boob','baby','mom','dad','tit','nut','egg','ass','twat','akh','abo','umm','anus','oral','rim','uterus','epstein','rape','goy','nipp','orgas','orgie','orgi','orge','hoe','weed','cum',];

const SUBSTRING_BANS = BANNED_WORDS.filter(w => w !== 'ass');

const RESERVED=['bobby','rob','eliminator','spectrebolt','admin','server','saifkayyali3','sunbul-k','you','player','skayyali3','developer'];

const DOMAIN_REGEX = /\b[a-z0-9-]{2,}\.(com|net|org|io|gg|dev|app|xyz|tv|me|co|info|site|online)\b/i;
const URL_SCHEME_REGEX = /(https?:\/\/|www\.)/i;

let lastNetSend = 0;
let lastTickTime = Date.now();
let players = {};
let bots = {};
let bullets = {};
let bulletIdCounter = 0;
let matchTimer = 15 * 60;
let walls = generateWalls(12);
let botAccumulator = 0;
let bulletAccumulator = 0; 
let NET_TICK = NET_TICK_IDLE;
let matchPhase = 'running'; 
let lastFirePacket = {};
let autogenerated = false;

const leetMap = {
    '0': ['o'], 
    '1': ['i', 'l'], 
    '2': ['z','s'], 
    '3': ['e'], 
    '4': ['a'], 
    '5': ['s','kh'], // 5 is like kh in arabic
    '6': ['g'], 
    '7': ['t','h'], // 7 is like h in arabic
    '8': ['b'], 
    '9': ['g'], 
    '@': ['a'], 
    '$': ['s'], 
    '!': ['i'], 
    '+': ['t'],
    '-': [''], 
    '_': [''], 
    '.': [''],
    'y':['i'],
    'i':['y'],
    'j':['g'],
    'g':['j'],
    'ch':['sh'],
    'sh':['ch']
};

function stripVowels(str) {
    return str.replace(/[aeiouy]/g, '');
}

function containsBannedWord(name) {
    const lower = name.toLowerCase();
    let variants = [lower];

    for (let key of Object.keys(leetMap)) {
        let newVariants = [];
        for (let v of variants) {
            if (v.includes(key)) {
                for (let rep of leetMap[key]) {
                    newVariants.push(v.split(key).join(rep));
                }
            } else {
                newVariants.push(v);
            }
        }
        variants = newVariants;
    }

    variants.push(lower,...variants.map(v => v.replace(/(.)\1+/g, '$1')));

    for (let v of variants) {
        for (let w of WORD_ONLY_BANS) {
            const re = new RegExp(`\\b${w}\\b`, 'i');
            if (re.test(v)) return true;
        }

        for (let w of SUBSTRING_BANS) {
            if (SAFE_SUBSTRING_BANS.includes(w)) {
                if (v.includes(w) || stripVowels(v).includes(stripVowels(w))) return true;
            } else {
                if (v.includes(w)) return true;
            }
        }
    }

    return false;
}

function isReservedName(name) {
    const lower = name.toLowerCase();
    return RESERVED.some(r =>
        new RegExp(`\\b${r}\\b`, 'i').test(lower)
    );
}

function isValid(name) {
    if (!/^[a-z0-9 _.-]{1,10}$/i.test(name)) return false;
    if (!/[a-z]/i.test(name)) return false;
    if (DOMAIN_REGEX.test(name) || URL_SCHEME_REGEX.test(name)) return false;
    return true;
}

function randomDigits() {
    return Math.floor(1000 + Math.random() * 9000);
}

function isNameTaken(name) {
    const normalized = name.toLowerCase();
    return Object.values(players).some(p =>
        p.name && p.name.toLowerCase() === normalized
    );
}

function rectsIntersect(r1, r2, padding = 0) {
    return (r1.x < r2.x + r2.w + padding && r1.x + r1.w + padding > r2.x && r1.y < r2.y + r2.h + padding && r1.y + r1.h + padding > r2.y);
}

function getBotSafeSpawn() {
    let x, y, attempts = 0;
    const MIN_DIST = 300;

    do {
        x = 100 + Math.random() * (MAP_SIZE - 200);
        y = 100 + Math.random() * (MAP_SIZE - 200);
        attempts++;
    } while (attempts < 100 && (collidesWithWall(x, y, 40) || Object.values(players).some(p =>!p.isSpectating && Math.hypot(p.x - x, p.y - y) < MIN_DIST)));
    return { x, y };
}

function generateWalls(count) {
    const newWalls = [];
    const MIN_CORRIDOR_WIDTH = 120;
    const MARGIN = 100;
    let attempts = 0;
    while (newWalls.length < count && attempts < 500) {
        attempts++;
        const w = 150 + Math.random() * 200;
        const h = 150 + Math.random() * 200;
        const x = MARGIN + Math.random() * (MAP_SIZE - w - MARGIN * 2);
        const y = MARGIN + Math.random() * (MAP_SIZE - h - MARGIN * 2);
        const candidate = { x, y, w, h };
        if (!newWalls.some(existing => rectsIntersect(candidate, existing, MIN_CORRIDOR_WIDTH))) {
            newWalls.push(candidate);
        }
    }
    return newWalls;
}

function collidesWithWall(x, y, r = ENTITY_RADIUS) {
    if (x < r || y < r || x > MAP_SIZE - r || y > MAP_SIZE - r) return true;
    return walls.some(w => x + r > w.x && x - r < w.x + w.w && y + r > w.y && y - r < w.y + w.h);
}

function getSafeSpawn() {
    let x, y, attempts = 0;
    const SPAWN_BUFFER = 50;
    do {
        x = SPAWN_BUFFER + Math.random() * (MAP_SIZE - SPAWN_BUFFER * 2);
        y = SPAWN_BUFFER + Math.random() * (MAP_SIZE - SPAWN_BUFFER * 2);
        attempts++;
    } while (collidesWithWall(x, y, SPAWN_BUFFER) && attempts < 100);
    return { x, y };
}

const USED_COLORS = new Set();

function generateUniqueColor() {
    let attempts = 0;

    while (attempts < 50) {
        const hue = Math.floor(Math.random() * 360);
        const color = `hsl(${hue},70%,50%)`;

        if (!USED_COLORS.has(color)) {
            USED_COLORS.add(color);
            return color;
        }

        attempts++;
    }

    return `hsl(${Math.random() * 360},70%,50%)`;
}

function shouldRespawnBot(botId) {
    if (matchTimer <= 0) return false;
    if (botId === 'bot_rob') return Math.random() < 0.75;
    if (botId === 'bot_eliminator') return Math.random() < 0.5;
    return true;
}

let specialsSpawned = {
    rob: false,
    eliminator: false
};

let specialsSpawnTimeout = null;

function spawnSpecialBots() {
    if (specialsSpawnTimeout) return; 
    specialsSpawnTimeout = setTimeout(() => {
        if (!specialsSpawned.rob && !bots['bot_rob'] && Math.random() < 0.75) {
            specialsSpawned.rob = true;
            const rob = new Bot('bot_rob', 'Rob', '#4A90E2', BASE_SPEED, 950);
            rob.damageTakenMultiplier = 0.75;
            bots['bot_rob'] = rob;
            io.emit('RobSpawned', {id: 'bot_rob', name: 'Rob', timestamp: Date.now()});
        }

        if (!specialsSpawned.eliminator && !bots['bot_eliminator'] && Math.random() < 0.25) {
            specialsSpawned.eliminator = true;
            const elim = new Bot('bot_eliminator', 'Eliminator', '#E24A4A', 3.9, 1100);
            elim.isRetreating = false;
            elim.damageTakenMultiplier = 0.4;
            bots['bot_eliminator'] = elim;
            io.emit('EliminatorSpawned', {id: 'bot_eliminator', name: 'Eliminator', timestamp: Date.now()});
        }
        specialsSpawnTimeout = null;
    }, 5000);
}

function isLeaderboardEligible(p) {
    return !p.forcedSpectator;
}

function handleSuccessfulJoin(socket, name,forcedSpectator = false, waitingForRematch=false) {
    const pos = getSafeSpawn();
    players[socket.id] = {
        id: socket.id,
        name: name,
        x: pos.x, 
        y: pos.y, 
        hp: 100, 
        lives: 3, 
        score: 0, 
        stamina: 100,
        angle: 0, 
        color: generateUniqueColor(),
        isSpectating: forcedSpectator, 
        forcedSpectator,
        spawnProtectedUntil: Date.now() + 3000,
        lastRegenTime: Date.now(),
        damageTakenMultiplier: 1,
        lastFireTime: 0,
        fireCooldown: 100, 
        input: {moveX: 0,moveY: 0,sprint: false,angle: 0},
        waitingForRematch,
        wantsRematch: false,          
        viewingGameOver: false,
    };

    socket.emit('init', { id: socket.id, mapSize: MAP_SIZE, walls, spawnX: pos.x, spawnY: pos.y,name, forcedSpectator, waitingForRematch,color:players[socket.id].color});
}

function maybeResetMatch() {
    const hasPlayers = Object.keys(players).length > 0;
    const anyAlive = Object.values(players).some(p => !p.isSpectating);

    if (!hasPlayers || (matchPhase === 'ended' && !anyAlive)) {
        resetMatch();
        return true;
    }

    return false;
}

function resetMatch() {
    matchTimer = 15 * 60;
    USED_COLORS.clear();

    bullets = {};

    walls = generateWalls(12);

    bots = {};
    bots['bot_bobby'] = new Bot('bot_bobby', 'Bobby', '#8A9A5B', 3.1, 800);
    bots['bot_bobby'].damageTakenMultiplier = 1.35;

    specialsSpawned.eliminator = false;
    specialsSpawned.rob = false;
    specialsSpawnTimeout = null;
    spawnSpecialBots();

    const anyWantsRematch = Object.values(players).some(p => p.wantsRematch);

    Object.values(players).forEach(p => {
        const pos = getSafeSpawn();
        if (anyWantsRematch) {
            if (p.wantsRematch) {
                Object.assign(p, {
                    id: p.id,
                    x: pos.x,
                    y: pos.y,
                    color: generateUniqueColor(),
                    hp: 100,
                    lives: 3,
                    stamina: 100,
                    spawnProtectedUntil: Date.now() + 3000,
                    lastRegenTime: Date.now(),
                    isSpectating: false,
                    waitingForRematch: false,
                    forcedSpectator: false,
                    score: 0,
                    input: { moveX: 0, moveY: 0, sprint: false, angle: 0 },
                    damageTakenMultiplier: 1,
                    lastFireTime: 0,
                    fireCooldown: 100,
                    justDied: false,
                    wantsRematch: false,
                    viewingGameOver: false
                });
            } else {
                Object.assign(p, {
                    isSpectating: true,
                    waitingForRematch: true,
                    hp: 0,
                    lives: 0,
                    score: 0,
                    wantsRematch: false
                });
            }
        } else {
            Object.assign(p, {
                id: p.id,
                x: pos.x,
                y: pos.y,
                color: generateUniqueColor(),
                hp: 100,
                lives: 3,
                stamina: 100,
                spawnProtectedUntil: Date.now() + 3000,
                lastRegenTime: Date.now(),
                isSpectating: false,
                waitingForRematch: false,
                forcedSpectator:false,
                score: 0,
                input: { moveX: 0, moveY: 0, sprint: false, angle: 0 },
                damageTakenMultiplier: 1,
                lastFireTime: 0,
                fireCooldown: 100,
                justDied:false,
                wantsRematch:false,
                viewingGameOver:false
            });
        }
    });

    io.emit('mapUpdate', { mapSize: MAP_SIZE, walls });
    matchPhase = 'running';
    io.emit('matchReset', { matchTimer, matchPhase });
}

class Bot {
    constructor(id, name, color, speed, bulletSpeed) {
        this.id = id; 
        this.name = name; 
        this.color = color;
        this.speed = speed; 
        this.bulletSpeed = bulletSpeed;
        const pos = getBotSafeSpawn();
        this.x = pos.x; 
        this.y = pos.y;
        this.hp = 100; 
        this.score = 0; 
        this.angle = 0;
        this.wanderAngle = Math.random() * Math.PI * 2;
        this.lastFireTime = 0;
        this.lastRegenTime = Date.now();
        this.spawnTime = Date.now();
        this.isRetreating = false;
        this.spawnProtectedUntil = 0;
        this.recentHits = 0;
        this.lastHitTime = 0;
        this.hitChain = 0;
        this.hasFiredWhileRetreating = false;
        this.lastAggressorId = null;
        this.lastAggressorTime = 0;
        this.reengageUntil = 0;
        this.fakeRetreatUsed = false;
    }

    fireAtPlayers(players) {
        if (collidesWithWall(this.x + Math.cos(this.angle) * 30, this.y + Math.sin(this.angle) * 30, 6)) return;

        if (Date.now() - this.spawnTime < 1200) return;
        if (Object.keys(bullets).length > MAX_BULLETS) return;

        const targets = Object.values(players).filter(p => !p.isSpectating);
        if (!targets.length) return;

        let nearest = targets.reduce((a, b) =>
            Math.hypot(a.x - this.x, a.y - this.y) <
            Math.hypot(b.x - this.x, b.y - this.y) ? a : b
        );

        const dist = Math.hypot(nearest.x - this.x, nearest.y - this.y);
        if (dist > 800) return;
        this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);

        const fireCooldown =this.id === 'bot_bobby' ? 1500 :this.id === 'bot_rob' ? 700 : 400; 

        let burstChance = 0;

        if (this.id === 'bot_eliminator') {
            if (this.recentHits >= 4) {
                burstChance = 1;
                this.recentHits = 0;
            } else {
                burstChance = 0.25;
            }
        }

        if (dist < 700 && Date.now() - this.lastFireTime > fireCooldown) {
            const shots = Math.random() < burstChance ? 4 : 1;

            for (let i = 0; i < shots; i++) {
                const id = 'bot_b' + (++bulletIdCounter);
                bullets[id] = {id,x: this.x,y: this.y,angle: this.angle + (Math.random() - 0.5) * 0.08,owner: this.id,speed: this.bulletSpeed / 60,born: Date.now()};
            }

            this.lastFireTime = Date.now();
        }
    }

    update(players) {
        let moveSpeed=this.speed
        if (Date.now() - this.lastRegenTime > 3000) {
            const maxHp =100;
            const regen = 5;

            this.hp = Math.min(maxHp, this.hp + regen);

            this.lastRegenTime = Date.now();
        }

        this.wanderAngle += (Math.random() - 0.5) * 0.2;

        const vx = Math.cos(this.wanderAngle);
        const vy = Math.sin(this.wanderAngle);
        const len = Math.hypot(vx, vy) || 1;

        let nx = this.x + (vx / len) * moveSpeed;
        let ny = this.y + (vy / len) * moveSpeed;

        if (!collidesWithWall(nx, ny, ENTITY_RADIUS)) {
            this.x = nx;
            this.y = ny;
        } else {
            this.wanderAngle += Math.PI;
        }

        this.fireAtPlayers(players);
    }
    updateAdvanced(players) {
        const now = Date.now();
        if (now - this.lastRegenTime > 3000) {
            const regen = this.isRetreating ? 2 : 5;
            this.hp = Math.min(100, this.hp + regen);
            this.lastRegenTime = now;
        }

        let moveSpeed = this.speed;
        if (this.id === 'bot_eliminator' && now - this.lastFireTime < 600) moveSpeed *= 0.5;

        if (this.hp <= 35) this.isRetreating = true;
        if (this.isRetreating) {
            moveSpeed *= 1.25;

            const targets = Object.values(players).filter(p => !p.isSpectating);
            if (targets.length) {
                const nearest = targets.reduce((a, b) =>
                    Math.hypot(a.x - this.x, a.y - this.y) <
                    Math.hypot(b.x - this.x, b.y - this.y) ? a : b
                );

                const angleToPlayer = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                this.angle = angleToPlayer + Math.PI;

                const distToPlayer = Math.hypot(nearest.x - this.x, nearest.y - this.y);
                const angleDiff = Math.abs(this.angle - angleToPlayer);
                if (!this.hasFiredWhileRetreating && distToPlayer < 400 && angleDiff > Math.PI / 2) {
                    const id = 'bot_b' + (++bulletIdCounter);
                    bullets[id] = {
                        id,
                        x: this.x,
                        y: this.y,
                        angle: angleToPlayer,
                        owner: this.id,
                        speed: this.bulletSpeed / 60,
                        born: now
                    };
                    this.hasFiredWhileRetreating = true;
                }
            }

            const lookahead = 40; 
            let nx = this.x + Math.cos(this.angle) * moveSpeed;
            let ny = this.y + Math.sin(this.angle) * moveSpeed;

            let attempts = 0;
            while (collidesWithWall(nx + Math.cos(this.angle) * lookahead, ny + Math.sin(this.angle) * lookahead, ENTITY_RADIUS) && attempts < 6) {
                this.angle += (Math.random() < 0.5 ? 1 : -1) * Math.PI / 6; 
                nx = this.x + Math.cos(this.angle) * moveSpeed;
                ny = this.y + Math.sin(this.angle) * moveSpeed;
                attempts++;
            }

            if (!collidesWithWall(nx, ny, ENTITY_RADIUS)) {
                this.x = nx;
                this.y = ny;
            } else {
                this.angle += Math.PI / 2;
            }

            if (this.hp >= 70) {
                this.isRetreating = false;
                this.hasFiredWhileRetreating = false;
            }

            this.x = Math.max(ENTITY_RADIUS, Math.min(MAP_SIZE - ENTITY_RADIUS, this.x));
            this.y = Math.max(ENTITY_RADIUS, Math.min(MAP_SIZE - ENTITY_RADIUS, this.y));
           
            return;
        }

        this.wanderAngle += (Math.random() - 0.5) * 0.08;
        const vx = Math.cos(this.wanderAngle);
        const vy = Math.sin(this.wanderAngle);
        const len = Math.hypot(vx, vy) || 1;

        let nx = this.x + (vx / len) * moveSpeed;
        let ny = this.y + (vy / len) * moveSpeed;

        if (!collidesWithWall(nx, ny, ENTITY_RADIUS)) {
            this.x = nx;
            this.y = ny;
        } else {
            this.wanderAngle += Math.PI;
        }
        this.fireAtPlayers(players);
        this.x = Math.max(ENTITY_RADIUS, Math.min(MAP_SIZE - ENTITY_RADIUS, this.x));
        this.y = Math.max(ENTITY_RADIUS, Math.min(MAP_SIZE - ENTITY_RADIUS, this.y));

    }
}

io.on('connection', socket => {
    socket.on('joinGame', (data) => {
        let rawName = (data.name || "").trim();
        let name = rawName.slice(0, 10);

        if (!rawName || rawName.toLowerCase() === "sniper") {
            name = "Sniper" + randomDigits();
            autogenerated = true;
        }
        if (!isValid(name)) {
            name = "Sniper" + randomDigits();
            autogenerated = true;
        }
        if (isReservedName(name)) {
            socket.emit('errorMsg', 'That name is reserved. Please try again');
            return;
        }
        if (isNameTaken(name)) {
            socket.emit('errorMsg', 'That name is already in use. Please try again.');
            return;
        }
        if (!autogenerated && containsBannedWord(name)) {
            name = "Imbecile" + randomDigits();
        }

        socket.playerName = name;

        if (Object.keys(players).length >= MAX_PLAYERS) {
            const minutesLeft = Math.ceil(matchTimer / 60);
            socket.emit('errorMsg', `Match is full. Time left: ${minutesLeft} minute${minutesLeft > 1 ? 's' : ''}.`);
            return;
        }

        let forcedSpectator = false;
        let waitingForRematch = false;

        const didReset = maybeResetMatch();

        if (!didReset && matchPhase !== 'running') {
            waitingForRematch = true;
        } else if (matchTimer <= JOIN_CUTOFF_SECONDS) {
            forcedSpectator = true;
        }

        if (!Object.keys(players).length && Object.keys(bots).length === 0) {
            bots['bot_bobby'] = new Bot('bot_bobby', 'Bobby', '#8A9A5B', 3.1, 800);
            bots['bot_bobby'].damageTakenMultiplier = 1.35;
            spawnSpecialBots();
        }

        handleSuccessfulJoin(socket, name, forcedSpectator, waitingForRematch);
        console.log(`${name} has joined the arena`);
    });
    socket.on('input', input => {
        const p = players[socket.id];
        if (!p || typeof input !== 'object') return;

        p.input = {moveX: Math.max(-1, Math.min(1, Number(input.moveX) || 0)),moveY: Math.max(-1, Math.min(1, Number(input.moveY) || 0)),sprint: !!input.sprint,angle: Number.isFinite(input.angle) ? input.angle : p.angle};
    });
    socket.on('fire', data => {
        const now = Date.now();
        if (lastFirePacket[socket.id] && now - lastFirePacket[socket.id] < 30) return;
        lastFirePacket[socket.id] = now;
        const p = players[socket.id];
        if (!p || p.isSpectating || p.lives <= 0 || p.forcedSpectator) return;

        const ownerBullets = Object.values(bullets).filter(b => b.owner === socket.id);
        if (ownerBullets.length >= 8) return;
        if (now - p.lastFireTime < p.fireCooldown) return; 
        p.lastFireTime = now;

        if (Object.keys(bullets).length > MAX_BULLETS) return;

        const id = 'b' + (++bulletIdCounter);
        bullets[id] = {
            id,
            x: p.x,
            y: p.y,
            angle: Number.isFinite(data.angle) ? data.angle : p.angle,
            owner: socket.id,
            speed: 900 / 60,
            born: now
        };
    });
    socket.on('viewingGameOver', (val) => {
        const p = players[socket.id];
        if (!p) return;
        p.viewingGameOver = !!val;
    });
    socket.on('disconnect', () => { 
        console.log(`${socket.playerName ?? 'Unknown player'} has left the arena`);

        const color = players[socket.id]?.color;

        delete players[socket.id];
        delete lastFirePacket[socket.id];

        if (color) USED_COLORS.delete(color);
    });
    socket.on('rematch', () => {
        const p = players[socket.id];
        if (!p) return;

        if (activeRematches.has(socket.id)) return;
        activeRematches.add(socket.id);

        p.wantsRematch = true;

        if (matchPhase === 'running') {
            const pos = getSafeSpawn();
            Object.assign(p, {
                id: socket.id,
                x: pos.x,
                y: pos.y,
                hp: 100,
                lives: 3,
                stamina: 100,
                score: 0,
                isSpectating: false,
                forcedSpectator: false,
                waitingForRematch: false,
                spawnProtectedUntil: Date.now() + 3000,
                lastRegenTime: Date.now(),
                justDied: false,
                color: generateUniqueColor(),
                wantsRematch: false,
                viewingGameOver: false
            });

        socket.emit('rematchAccepted', { id: p.id, x: p.x, y: p.y, matchTimer, matchPhase, color: p.color });
        activeRematches.delete(socket.id);
        return;
    }

    if (matchPhase === 'ended') {
        maybeResetMatch();
        socket.emit('rematchAccepted', { id: p.id, matchTimer, matchPhase, color: p.color });
        activeRematches.delete(socket.id);
        return;
    }

        socket.emit('rematchQueued');
        activeRematches.delete(socket.id);
    });
});

setInterval(() => {
    const playerArray = Object.values(players);
    if (playerArray.length > 0) {
        const anyAlive = playerArray.some(p => !p.isSpectating);
        if (!anyAlive && matchTimer > 0) {
            matchTimer = 0;
        }
    }

    const now = Date.now();
    const delta = Math.min((now - lastTickTime) / 1000, 0.05);
    lastTickTime = now;

    const activePlayersArray = Object.values(players).filter(p => !p.isSpectating);
    NET_TICK = activePlayersArray.length > 0 ? NET_TICK_ACTIVE : NET_TICK_IDLE;

    if (activePlayersArray.length === 0) {
        if (matchTimer <= 0 && matchPhase !== 'ended') {
            matchPhase = 'ended';
            console.log("Match ended due to timer.");
        }
    } else {
        NET_TICK = NET_TICK_ACTIVE;
        if (matchPhase === "running") {
            matchTimer = Math.max(0, matchTimer - delta);
        }
    }

    Object.values(players).forEach(p => {
        if (p.waitingForRematch) return;
        if (!p.isSpectating && Date.now() - p.lastRegenTime > 3000) {
            p.hp = Math.min(100, p.hp + 5);
            p.lastRegenTime = Date.now();
        }
        
        const input = p.input || {sprint:false};
        let speed = p.isSpectating ? 15 : (p.input.sprint && p.stamina > 0? SPRINT_SPEED: BASE_SPEED);

        let dx = input.moveX || 0;
        let dy = input.moveY || 0;

        if (!p.isSpectating){
            if (p.input.sprint && (dx || dy)) {
                p.stamina = Math.max(0, p.stamina - 1);
            } else {
                p.stamina = Math.min(100, p.stamina + 0.6);
            }
        }
        if (p.isSpectating) {
            const sx = Math.abs(dx) > 0.01 ? dx : 0;
            const sy = Math.abs(dy) > 0.01 ? dy : 0;
            p.x += sx * speed * delta * 60;
            p.y += sy * speed * delta * 60;

            p.x = Math.max(ENTITY_RADIUS, Math.min(MAP_SIZE - ENTITY_RADIUS, p.x));
            p.y = Math.max(ENTITY_RADIUS, Math.min(MAP_SIZE - ENTITY_RADIUS, p.y));
            return;
        }

        if (dx || dy) {
            const len = Math.hypot(dx, dy);

            if (len > 1) {
                dx /= len;
                dy /= len;
            }
            const moveFactor = delta * 60;
            let nx = p.x + dx * speed * moveFactor;
            if (!collidesWithWall(nx, p.y, ENTITY_RADIUS)) {
                p.x = nx;
            }

            let ny = p.y + dy * speed * moveFactor;
            if (!collidesWithWall(p.x, ny, ENTITY_RADIUS)) {
                p.y = ny;
            }
        }
        p.angle = p.input.angle;
    });
    botAccumulator += delta;
    if (botAccumulator >= 1 / 30) {
        Object.values(bots).forEach(b => {
            if (b.retired) return;
            if (b.id === 'bot_eliminator') b.updateAdvanced(players);
            else b.update(players);
        });
        botAccumulator = 0;
    }
    bulletAccumulator += delta;

    while (bulletAccumulator >= 1 / 15) {
        bulletAccumulator -= 1/15;

        Object.values(bullets).forEach(b => {
            if (Date.now() - b.born > BULLET_LIFETIME) {
                delete bullets[b.id];
                return;
            }

            const bulletStep = (1/15)*60;
            b.x += Math.cos(b.angle) * b.speed * bulletStep;
            b.y += Math.sin(b.angle) * b.speed * bulletStep;

            if (collidesWithWall(b.x, b.y, BULLET_RADIUS) || b.x < 0 || b.x > MAP_SIZE || b.y < 0 || b.y > MAP_SIZE) {
                delete bullets[b.id];
                return;
            }

            const livePlayers = Object.values(players).filter(p => !p.isSpectating);
            const liveBots = Object.values(bots).filter(b => !b.retired);
            for (const target of [...livePlayers, ...liveBots]) {
                if (Math.abs(target.x - b.x) > 40 || Math.abs(target.y - b.y) > 40) continue;
                if (target.id === b.owner ||target.isSpectating || Date.now() < target.spawnProtectedUntil || target.retired || target.hp<=0) continue;
                if (!target || target.viewingGameOver || target.waitingForRematch) continue;

                const dx = b.x - target.x;
                const dy = b.y - target.y;
                const HIT_RADIUS = ENTITY_RADIUS + BULLET_RADIUS + 6;

                let damage = 10;
                const shooter = players[b.owner] || bots[b.owner];
                if (dx * dx + dy * dy < HIT_RADIUS * HIT_RADIUS) {
                    if (target.id === 'bot_rob') {
                        const now = Date.now();
                        if (now - target.lastHitTime < 250) target.hitChain++;
                        else target.hitChain = 0;
                        target.lastHitTime = now;
                        const spamReduction = Math.min(0.6, target.hitChain * 0.1);
                        damage *= (1 - spamReduction);
                    }

                    if (target.id === 'bot_eliminator') {
                        const now = Date.now();
                        if (now - target.lastHitTime < 400) target.recentHits++;
                        else target.recentHits = 1;
                        target.lastHitTime = now;
                    }

                    if (target.id === 'bot_eliminator' && shooter && shooter.id) {
                        target.lastAggressorId = shooter.id;
                        target.lastAggressorTime = Date.now();
                    }

                    let multiplier = target.damageTakenMultiplier ?? 1;

                    if (target.id === 'bot_eliminator') {
                        if (target.isRetreating) {
                            multiplier *= 1.35; 
                        } else {
                            multiplier *= 0.75; 
                        }
                    }

                    target.hp -= damage * multiplier;
                    target.hp = Math.max(0, target.hp);

                    target.lastRegenTime = Date.now();

                    delete bullets[b.id]; 

                    if (target.hp <= 0) {
                        if (target.justDied) {
                            delete bullets[b.id];
                            break;
                        }

                        target.justDied = true;
                        const victimName = target.name;
                        const shooterName = shooter ? shooter.name : "The Void";

                        let pointsAwarded = 0;

                        if (shooter) {
                            if (b.owner.toString().includes('bot')) {
                                if (!target.id.toString().includes('bot')) pointsAwarded = b.owner === 'bot_bobby' ? 6 : 3;
                            } else {
                                if (target.id === 'bot_bobby') pointsAwarded = 1;
                                else if (target.id === 'bot_eliminator') pointsAwarded = 6;
                                else pointsAwarded = 3;
                            }
                            shooter.score += pointsAwarded;
                        }

                        io.emit('killEvent', { shooter: shooterName, victim: victimName });

                        if (!target.id.toString().includes('bot')) {
                            target.lives--;
                            if (target.lives <= 0) {
                                target.hp = 0;
                                target.isSpectating = true;
                                target.justDied = false;
                            } else {
                                const respawnPos = getSafeSpawn();
                                Object.assign(target, {
                                    x: respawnPos.x,
                                    y: respawnPos.y,
                                    hp: 100,
                                    stamina: 100,
                                    spawnProtectedUntil: Date.now() + 3000,
                                    lastRegenTime: Date.now(),
                                    justDied:false
                                });

                                io.to(target.id).emit('respawned', {x: target.x, y: target.y});
                            }
                        } else {
                            if (shouldRespawnBot(target.id)) {
                                const respawn = getBotSafeSpawn();
                                Object.assign(target, {hp: 100,x: respawn.x,y: respawn.y,spawnTime: Date.now(),justDied:false});
                            } else {
                                target.retired=true;
                                if (!target.retireAnnounced) {
                                    target.retireAnnounced = true;
                                    if (target.id === 'bot_eliminator') {
                                        io.emit('EliminatorRetired', 'The Eliminator has fallenâ€¦');
                                    } else if (target.id === 'bot_rob') {
                                        io.emit('RobRetired', 'Rob has left the arena.');
                                    }
                                }
                            }
                        }
                    }
                }
            }
        });
    }

    if (Date.now() - lastNetSend > NET_TICK) {
        const slimPlayers = {};
        for (const [id, p] of Object.entries(players)) {
            if (!isLeaderboardEligible(p)) continue;
            slimPlayers[id] = {id,x: p.x,y: p.y,hp: p.hp,angle: p.angle,isSpectating: p.isSpectating,forcedSpectator: p.forcedSpectator,spawnProtected: Date.now() < p.spawnProtectedUntil,stamina: p.stamina,score:p.score,lives:p.lives,color:p.color,name:p.name,waitingForRematch: !!p.waitingForRematch,};
        }

        const slimBots = {};
        for (const [id, b] of Object.entries(bots)) {
            slimBots[id] = {id: b.id,x: b.x,y: b.y,hp: b.hp,score: b.score,angle: b.angle,name: b.name,color: b.color,retired: !!b.retired};
        }

        const slimBullets = {};
        for (const [id, b] of Object.entries(bullets)) {
            if (Object.values(players).some(p =>!p.isSpectating && Math.hypot(p.x - b.x, p.y - b.y) < 900)) {
                slimBullets[id] = { x: b.x, y: b.y, angle: b.angle };
            }
        }

        io.emit('state', { players:slimPlayers, bots:slimBots, bullets:slimBullets, matchTimer, matchPhase });
        lastNetSend = Date.now();
    }
}, TICK_RATE);

app.get('/health', (req, res) => {
  res.status(200).send('ok');
});

server.listen(PORT, '0.0.0.0', () => { 
    console.log(`Spectrebolt Arena Server Active on Port ${PORT}`); 
    console.log(`Running on http://localhost:${PORT}`)
});